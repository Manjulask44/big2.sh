Kubernetes Installation
	Minimum system requirement for master nod is 2-core cpu and 4GB RAM
	
	1. sudp apt update 
	2. sudo apt-get install -y apt-transport-https
	3. sudo su -
	4. curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add
	5. echo 'deb http://apt.kubernetes.io/ kubernetes-xenial main' > /etc/apt/sources.list.d/kubernetes.list
	6. sudo apt update 
	7. sudo apt-get install -y docker.io
	8. sudo systemctl start docker
	9. sudo systemctl enable docker.service
	9. sudo apt-get install -y kubelet kubeadm kubectl kubernetes-cni
	
	10. Create a ami from above instance to create workernodes 
	
	11. After ami is available, login again to master node 
		(Make sure docker is running)
		12. sudo su -
		13. kubeadm init
			ERROR1: if we get kubelet isn't running or healthy
						kubelet doesnt got access to docker engine which means 
						we need to configure cgroup of docker 
					create a file /etc/docker/daemon.json with below content
						{
							"exec-opts": ["native.cgroupdriver=systemd"]
						}
					Reload docker daemon
						systemctl daemon-reload
						systemctl restart docker
						systemctl restart kubelet
					
			Run kubeadm init again	
			
			ERROR2: if we get fileavailable error just delete those files 
			ERROR3: if kubelet is running kill it 
						lsof -i :<kublet_port>
						kill -9 <process_id>
			
			Run kubeadm init again	
				if we get kubeadm join command at the end means master node 
				setup is successful and save the join command.

		14. configure K8S kubectl 		
			- exit from the root 
			- copy the default k8s conf file to our home directory 
					mkdir -p $HOME/.kube
					sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
					sudo chown $(id -u):$(id -g) $HOME/.kube/config
		
		15. We install k8s CNI Driver
			sudo sysctl net.bridge.bridge-nf-call-iptables=1
			kubectl apply -f "https://cloud.weave.works/k8s/v1.13/net.yaml"
			
			check for node status - kubectl get nodes
		
		16.	Login to worker node 
			sudo su -
			create a file /etc/docker/daemon.json with below content
				{
					"exec-opts": ["native.cgroupdriver=systemd"]
				}
			Reload docker daemon
				systemctl daemon-reload
				systemctl restart docker
				systemctl restart kubelet		
				
			Now open ports of master nodes 
			
			Run the join command with token which we got from master node 
			
			Repeat the same steps in other worker nodes
			
kubernetes Architecture 	
	The architecture of k8s differs from master and worker node 

	Master node components 
		1. Api Server / kube-api-server
			- It is the main managemnet point of the cluster and also called 
			  as brain of the cluster.
			- All the components are directly connected to API serve, they 
			  communicate through API server only and no other component will 
			  communicate directly with eachother.
			- This is the only component which connects and got access to etcd.
			- All the cluster requests are authenticated and authorized by API server.
			- API server has a watch machanism for watching the changes in cluster.
			
		2. etcd 
			- ectd is a distributed , consistent key value store used for 
			  storing the complete cluster information/data.
			- ectd contains data such as configuration managemnet of cluster,
              distributed work and basically complete cluster information.			
			
		3. scheduler / kube-scheduler
			- The scheduler always watches for a new pod request and 
			  decides which worker node this pod should be created.
			- Based on the worker node load, affinity and anti-affiny, taint configuration 
			  pod will be scheduled to a particualr node.
			  
		Controller manager /control manager / kube-controller 
			- It is a daemon that always runs and embeds core control loops known as controllers. 
			- K8s has some inbuild controllers such as Deployment, DaemonSet, ReplicaSet, Replication controller,
			  node controller, jobs, cronjob, endpoint controller, namespace controller etc.	
			
		Cloud controller manager 
		
		
		
	Worker node components 
		kubelet 
			- It is an agent that runs on each and every worker node and it alsways watches the API 
			  server for pod related changes running in its worker node.
			- kubelet always make sure that the assigend pods to its worker node is running.
			- kubelet is the one which communicates with containarisation tool (docker daemon)
              through docker API (CRI). 	
			- work of kubelet is to create and run the pods. Always reports the status of the worker node 
			  and each pod to API server. (uses a tool call cAdvisor)
			- Kubelet is the one which runs probes.	
		
		kube service proxy 
			(in k8s service means networking)
			- Service proxy runs on each and every worker node and is responsble for watching API 
			  server for any changes in service configuration (any network related configuration).	
			- Based on the configuration service proxy manages the entire network of worker node.

		Container runtime interface (CRI)
			- This component initialy identifies the container technology and connects it to kubelet.
			
			
		pod
			- pods are the smallest deployable object in kuberntes.
			- pod should contain atleast one container and can have n number of containers.
			- If pod contains more than one container all the container share the same memory assigned to that pod.
			
			
YAML file 
	- Filetype .yaml / .yml 
	- YAML file will contain key value pairs where key is fixed and defined by the tool and value is 
	  user defined configuration. 
    - values supports multiple datatypes - string, Integer, Boolean, Array, List and dictionary.

	example:
		1)	name: Harsha
			hobbies: ["Driving","coding"]
			
				(or)
				
			name: harsha
			hobbies: 
				- Driving
				- coding
			
		2)  candidates: 
			   - name: a
			      firstname:
			      lastname: 	
			     age: 25
			   - name: b
			     age: 29
				 
example pod
	apiVersion: v1
		- This is used to specify the version of API t create a particular k8s object.
		- The field is casesentive, it will be in camelcase 
		- The types of API we have in k8s are alpha, beta and stable versions.
		
	kind: Pod 
		- used to specify the type of k8s object to create.
		- Always object name first letter is capital.
		
	metadata: 
		contains the information that helps us to uniquely identify the object.
		There are 3 types of metadata 
			1. name 
			2. labels 
				- k8s labels us used to identify the object.
				ex: name, evironment, tier, release.
			3. annotations

	spec: 
       - actual configuration of the objects 	
	   
	   
apiVersion: v1
kind: Pod 
metadata: 
    name: my-first-pod	
spec: 
    containers:
       - name: my-nginx 
         image: nginx:latest
		 ports: 
		    - containerPort: 80
	
TO create / apply a configuration 
	kubectl apply -f <file>.yml	
	
To list objects 
	kubectl get <obeject_type>
		ex: List pods - kubectl get pods 
		    List deployment - kubectl get deployments
			
To delete objects 
	kubectl delete <object_type>


Assignment: What happens if we create a pod with kubectl ?
	
K8S Labels and selectors 
	- K8S labels is a metadata key value which can be applied to any object in k8s.
	- Labels are used to identify by using selectors.
	- Multiple objects can have same label, multiple labels to same object and Label lenght should be less that 63 characters.
	
	TO list all labels of a object 
		kubectl get <obeject_type> <obejct_name> --show-labels 
	
	
	Selectors 
		- Selectors are used to filter and identifly the labeled k8s object.
		
		Equality-Based 
			- It will use only one label in comparision and it will look for objects with exact same 
			  string in label.
			- we can use 3 types of operators equal ( = or == ) and not-qual ( != )	
		
			example: 
				selectors: 
					matchLabels: 
						app=nginx 
						   (or)
						app: nginx   
		
		set-based 
			- This type of selector allows us to filter objects based on multiple set of values to a label key.
			- 3 types of operators we can use in, notin and exists.

				example: 
					selectors: 
						matchLabels: 
							app in (nginx, my-nginx)
							app exits (nginx, my-nginx)
							app notin (nginx, my-nginx)
Annotations 
	- These are used for record purpose only and to provide some user information to objects.
	- These are non-identifying metadata so we cannot use selectors on annotations.

	example: personal_info, phone_number, imageregistry, author	
	
Assignment: Difference b/w set-based and equality-based selector.
			Difference b/w labels and annotations.

ReplicaSet vs Replication Controller
	- Both ensures that a specified number of pod replicas are alyways running at a given point of time.
	- Replication controller is a very old way of replicating the pos and now it is replaced by ReplicaSet
      
	- The only differenece b/w them is their selector types.
		Replication Controller supports only equality-based selector. 
		ReplicaSet supports both equality-based and set-based selectors.

Deployment controller / Deployment / k8s deployment 
	- Deployment is used to create replicas of pod and it makes sure at a given point of time 
	  the number of replicas of pod is alway running. 
	- Deployment internally uses ReplicaSet to replicate the pods.
	- If we update the configuration in deployment it will automatically updates it to all the pods.
	- Rollout and Rollback of pod update is possible.
	- we can pause a deployment whenerver we need.
	- Deployment has got its own internal autoscaller which is of type horizontal scaller. 
		To apply calling 
			kubectl autoscale deployment.v1.apps/<deployment_name> --min=5 --max=20 --cpu-percent=50	
	- scaleup and scaledown is possible by increasing and decreasing the replica count at any given 
	  point of time.
		kubectl scale deployment.v1.apps/<deployment_name> --replicas=10	
	
	- deployment is a cluster level object.
	
		deployment = pod + ReplicaSet + autoscaling + RollingUpdates 
	
	Deployment spec file.
		
		apiVersion: apps/v1
		kind: Deployment
		metadata:
		  name: nginx-deployment-new
		  labels:
			app: my-deployment-nginx
		spec:
		  replicas: 5
		  selector:
			matchLabels:
			  app=nginx
		  template:
			metadata:
			  labels:
				app: nginx
			spec:
			  containers:
			  - name: nginx
				image: nginx:1.14.2
				ports:
				- containerPort: 80
	
Assignment for me: demo on selectors types 
	
DaemonSet
	- DaemonSet ensures that a copy of pod is always running on all the worker nodes in the cluster.
	-If a new node is added or if deleted DaemonSet will automatically adds/deletes the pod.

	usage: 
		- we use DaemonSet to deploy monitoring agents in every worker node.
		- Log collection daemons: to grab the logs from worker and all the pods running in it.
		
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: nginx-daemonset
spec:
  selector:
	matchLabels:
	  app: daemonset-nginx
  template:
	metadata:
	  labels:
		app: daemonset-nginx
	spec:
	  containers:
	  - name: nginx
		image: nginx:1.14.2
		ports:
		 - containerPort: 80		
		 
Statefull Applications 
	- User session data is saved at the server side.
	- if server goes down, it is difficult to transfer the session data to other server. 
	- This type of application will not work, if we want to implement autoscalling.
	
Stateless Applications
	- user sessiondata is never saved at the server side.
	- using a common authentication gateway / client token method to validate the users 
	  once for multiple microservices.	
		
https://medium.com/tech-tajawal/microservice-authentication-and-authorization-solutions-e0e5e74b248a		

Monolothic and Microservice architecture 

	Monolothic architecture
		- A monolothic application has a single code base with multiple moduels in it.
		- It is a single build for entire application.
		- To make minor changes to application, we need to re-build and re-deploy the 
		  complete application.
		- scalling is very challenging.
			
	Microservice architecture 
		- A microservice application is composed of small (micro) services. 
		- Each service will have a different code base.
		- Application are divided into as small as possible sub applications called services
		  which are independent to each other which are called loosly coupled.	
		- Each service can be managed seperately and it is deployable seperately.
		- Services need not to share same technology stack or frameworks.		 

StatefulSet 
	- StatefulSet = Deployment + sticky identity for each and every pod replica.
	- Unlike a deployment a StatefulSet maintains a sticky identity for each of the pod.
		
Node controller 
	- Looks for node statuses and reponds to API server only when a node is down.

Endpoint Controller
	- Populates the information of endpoints of all the objects.	
		
Service (svc)
	- Service is an REST api objects with set of policies for defining the 
	  access to set of pods.
	- Services are the default load balancer in k8s.
	- services are always created and works at cluster level.
	- services are the networking configurations which we do in k8s.
	- k8s prefers to use 30000 - 50000 range of ports to define services.

1. ClusterIP
	- This is the default type of service which exposes the IPs of pod to the other pods 
	  with in the same cluster.
	- ClusterIP cannot be accessed outside cluster.
	- services are the default loadbalancers of k8s.
	
	apiVersion: v1 
	kind: Service 
	metadata:
	     name: my-svc 
	spec: 
		type: ClusterIP
		selector: 
			app: my-nginx 
		ports: 
			- name: http
			  port: 30080
			  targetPort: 8080	
